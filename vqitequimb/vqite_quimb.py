"""Variational Quantum Imaginary Time Evolution (VQITE) using tensor networks.

This module implements VQITE simulations using tensor network methods for efficient
quantum state evolution. It leverages several key libraries:

- Quimb: Provides tensor network operations and contractions
- Cotengra: Optimizes tensor network contraction paths
- MPI4py: Enables parallel computation across multiple processes

The implementation focuses on performance and scalability through:
- Efficient tensor network representations of quantum states
- Optimized contraction strategies
- Parallel computation capabilities

Example Usage:
    See the accompanying notebooks for detailed examples:
    - vqite_timing_test.ipynb: Performance benchmarking
    - one_step_timing_test_and_MV_avqite_comparison.ipynb: Comparison with other methods
Notes:
    See requirements.txt for complete dependency information and version requirements.
"""

import pickle
import time

import numpy as np
import quimb as qu
import quimb.tensor as qtn

try:
    from mpi4py import MPI

    mpi_available = True

except ImportError:
    # Fallback: Serial mode
    mpi_available = False


class ModelH:
    """Class representing a quantum Hamiltonian model constructed from an incar_file.

    This class parses an incar_file in AVQITE format to construct a Hamiltonian
    as a sum of Pauli string operators with coefficients.

    Attributes
    ----------
    incar_file : str
        Path to the incar_file in AVQITE format containing the Hamiltonian
        specification.
    paulis : List[str]
        List of Pauli string operators (e.g. ["IXYZ", "ZZII"]) that form
        the Hamiltonian.
    coefs : List[float]
        List of coefficients corresponding to each Pauli string operator.

    Notes
    -----
    The incar_file should follow the AVQITE format specification.

    """

    def __init__(self, incar_file: str) -> None:
        """Initialize a ModelH instance.

        Parameters
        ----------
        incar_file : str
            Path to the input file in AVQITE format that specifies the Hamiltonian
            as a sum of Pauli string operators with coefficients.

        Returns
        -------
        None

        Notes
        -----
        The incar_file should contain the Hamiltonian specification between 'h' and
        'pool' markers in AVQITE format. The file is parsed to extract:
        - Pauli string operators (stored in self.paulis)
        - Corresponding coefficients (stored in self.coefs)

        """
        self.incar_file = incar_file
        with open(self.incar_file) as fp:
            incar_content = fp.read()
        h_pos = incar_content.find("h")
        pool_pos = incar_content.find("pool")
        h_string = incar_content[h_pos + 14 : pool_pos - 14]

        self.paulis = "".join(
            [
                el
                for el in h_string
                if el == "I" or el == "X" or el == "Y" or el == "Z" or el == "\n"
            ]
        ).split("\n")
        coefs_str = "".join(
            [
                el
                for el in h_string
                if el.isdigit() or el == "-" or el == "." or el == "*"
            ]
        ).split("*")
        self.coefs = [float(el) for el in coefs_str[0:-1]]


class QuimbVqite:
    """Performs Variational Quantum Imaginary Time Evolution (VQITE) using Quimb.

    This class implements VQITE using the Quimb tensor network library. It reads an
    ansatz generated by AVQITE and evolves it in imaginary time to find ground state.

    Attributes
    ----------
    _incar_file : str
        Path to input file containing Hamiltonian and reference state specification
    _ansatz_file : str
        Path to file containing AVQITE-generated ansatz form
    _output_file : str
        Path where results will be written
    _init_params : str or list
        Initial parameters for the ansatz. Can be:
        - 'random': Random perturbation around AVQITE solution
        - 'zeros': All zeros
        - 'avqite': Use AVQITE solution directly
        - list: Custom parameter values
    _comm : MPI.COMM_WORLD
        MPI communicator for parallel execution
    _size : int
        Total number of MPI processes
    _rank : int
        Rank of current MPI process
    _num_qubits : int
        Number of qubits in the system
    _ansatz : list[str]
        List of Pauli strings defining the ansatz form
    _params_solution : list[float]
        AVQITE-calculated parameters (fixed reference)
    params : list[float]
        Current ansatz parameters being optimized
    _m : ndarray
        VQITE M matrix for parameter updates
    _m_width : ndarray
        Contraction widths for M matrix elements
    _m_cost : ndarray
        Contraction costs for M matrix elements
    _v : ndarray
        VQITE V vector for parameter updates
    _ref_state : str
        Initial reference state specification
    _init_qc : Circuit
        Quantum circuit for reference state preparation
    _pauli_rot_gates_list : list[Gate]
        Quimb gates implementing ansatz Pauli rotations
    _pauli_rot_dag_gates_list : list[Gate]
        Quimb gates implementing inverse ansatz rotations
    _base_circuits : list[Circuit]
        Quantum circuits truncated at each ansatz layer
    h_terms_reh_dict : dict
        Cached tensor network representations for Hamiltonian terms
    optimize_dict : dict
        Cached optimal contraction paths for expectation values

    Notes
    -----
    - The implementation uses MPI for parallel computation of matrix elements.
    - Tensor network contractions are optimized using Quimb's contraction path finding.
    - The ansatz file must be in AVQITE format (.pkle).
    - The reference state must be specified as a string of '0's and '1's.

    See Also
    --------
    ModelH : Class for handling Hamiltonian terms
    add_pauli_rotation_gate : Function for adding Pauli rotation gates

    """

    def __init__(
        self,
        incar_file: str,
        ansatz_file: str,
        output_file: str,
        init_params: str | list[float] = "random",
    ) -> None:
        """Initialize a QuimbVqite instance.

        Parameters
        ----------
        incar_file : str
            Path to input file containing Hamiltonian and reference state specifications
        ansatz_file : str
            Path to AVQITE format (.pkle) file containing ansatz form and parameters
        output_file : str
            Path where calculation outputs will be written
        init_params : str or list[float], optional
            Initial parameter strategy, by default "random". Options:
            - "random": AVQITE parameters plus random noise in [-0.05, 0.05]
            - "zeros": All parameters set to 0.0
            - "avqite": Use parameters from AVQITE solution
            - list: Custom parameter values matching ansatz length

        Raises
        ------
        NotImplementedError
            If init_params is not one of the valid options
        ValueError
            If reference state specification is invalid

        """
        self._incar_file = incar_file
        self._ansatz_file = ansatz_file
        self._output_file = output_file
        self._init_params = init_params

        if mpi_available:
            self._comm = MPI.COMM_WORLD
            self._size = self._comm.Get_size()
            self._rank = self._comm.Get_rank()
        else:
            self._rank = 0
            self._size = 1

        # Reads out the Hamiltonian from the incar file.
        self._H = ModelH(self._incar_file)
        # The number of qubits is determined from there.
        self._num_qubits = len(self._H.paulis[0])

        # Reads out the form of the ansatz and the parameters of the ansatz from
        # the ansatz file.
        # The ansatz file should be in the AVQITE format.
        (self._ansatz, self._params_solution) = read_adaptvqite_ansatz(
            self._ansatz_file
        )
        # For the purposes of VQITE, we might want to set the initial parameters
        # to be random.
        if self._init_params == "random":
            self.params = [
                self._params_solution[i] + np.random.uniform(-0.05, 0.05)
                for i in range(len(self._ansatz))
            ]
        elif self._init_params == "zeros":
            self.params = [0.0 for _ in range(len(self._ansatz))]
        elif self._init_params == "avqite":
            self.params = self._params_solution.copy()
        elif isinstance(self._init_params, list) and len(self._init_params) == len(
            self._ansatz
        ):
            self.params = self._init_params.copy()
        else:
            raise NotImplementedError(
                "self._init_params has to be either random, avqite, or a list"
            )

        # Matrix M and cvctor V used in VQITE.
        self._m = np.zeros((len(self._ansatz), len(self._ansatz)))
        self._m_width = np.zeros((len(self._ansatz), len(self._ansatz)))
        self._m_cost = np.zeros((len(self._ansatz), len(self._ansatz)))

        self._v = np.zeros(len(self._ansatz))

        # Reads out the incar file.
        with open(self._incar_file) as fp:
            incar_content = fp.read()
        ref_st_r_pos = incar_content.find("ref_state")

        # Reads out the reference state from the incar file.
        self._ref_state = incar_content[
            ref_st_r_pos + 13 : ref_st_r_pos + 13 + self._num_qubits
        ]

        # Initializes a quantum circuit.
        self._init_qc = qtn.Circuit(N=self._num_qubits)

        # If the reference state contains "1"s, adds corresponding bit-flips.
        if all((el == "0") or (el == "1") for el in self._ref_state):
            [
                self._init_qc.apply_gate("X", i)
                for i, el in enumerate(self._ref_state)
                if el == "1"
            ]
        else:
            raise ValueError("Reference state is supposed to be a string of 0s and 1s")

        # Creates and saves a set of gates in Quimb corresponding to Pauli
        # rotations (and their inverse) from the ansatz.
        # This will be used throghout the calculations.
        # Here we create separate lists for circuits and for gates because Quimb
        # does not have functionality to reparameterize gates, only circuits.
        self._pauli_rot_circuits_list = [
            add_pauli_rotation_gate(
                qc=qtn.Circuit(N=self._num_qubits),
                pauli_string=self._ansatz[i],
                theta=self.params[i],
                decompose_rzz=False,
            )
            for i in range(len(self._ansatz))
        ]
        self._pauli_rot_gates_list = [
            self._pauli_rot_circuits_list[i].gates for i in range(len(self._ansatz))
        ]
        self._pauli_rot_dag_circuits_list = [
            add_pauli_rotation_gate(
                qc=qtn.Circuit(N=self._num_qubits),
                pauli_string=self._ansatz[i],
                theta=-self.params[i],
                decompose_rzz=False,
            )
            for i in range(len(self._ansatz))
        ]
        self._pauli_rot_dag_gates_list = [
            self._pauli_rot_dag_circuits_list[i].gates for i in range(len(self._ansatz))
        ]

        # Creates and saves circuits in Quimb correspondning to the product of
        # Pauli rotations up to mu'th rotation in the ansatz list, where
        # mu is the index.
        # This will be used throghout the calculations.
        self._base_circuits = [
            self.circuit_2(mu) for mu in range(len(self._ansatz) + 1)
        ]

    def log(self, message: str) -> None:
        """Log a message to the output file."""
        with open(self._output_file, "a") as f:
            print(message, file=f)

    def update_params(self) -> None:
        """Update the circuit parameters to match the current values in self.params.

        This method synchronizes all the stored quantum circuits and gates with the
        current parameter values. Specifically, it updates:

        - self._pauli_rot_circuits_list: Forward Pauli rotation circuits
        - self._pauli_rot_gates_list: Gates extracted from forward circuits
        - self._pauli_rot_dag_circuits_list: Adjoint (inverse) Pauli rotation circuits
        - self._pauli_rot_dag_gates_list: Gates extracted from adjoint circuits
        - self._base_circuits: Product circuits up to each rotation index

        The method must be called whenever self.params is modified to ensure all
        quantum circuits use the current parameter values.

        Returns
        -------
        None

        """
        for k in range(len(self._ansatz)):
            old_params_dict = self._pauli_rot_circuits_list[k].get_params()
            new_params_dict = {
                key: np.array([self.params[k]]) for key in old_params_dict.keys()
            }
            self._pauli_rot_circuits_list[k].set_params(new_params_dict)

        self._pauli_rot_gates_list = [
            self._pauli_rot_circuits_list[k].gates for k in range(len(self._ansatz))
        ]
        for k in range(len(self._ansatz)):
            old_params_dict = self._pauli_rot_dag_circuits_list[k].get_params()
            new_params_dict = {
                key: np.array([-self.params[k]]) for key in old_params_dict.keys()
            }
            self._pauli_rot_dag_circuits_list[k].set_params(new_params_dict)

        self._pauli_rot_dag_gates_list = [
            self._pauli_rot_dag_circuits_list[k].gates for k in range(len(self._ansatz))
        ]
        for mu in range(len(self._ansatz) + 1):
            old_params_dict = self._base_circuits[mu].get_params()
            new_params_dict = {
                key: np.array([self.params[i]])
                for i, key in enumerate(old_params_dict.keys())
            }
            self._base_circuits[mu].set_params(new_params_dict)

    def compute_m(
        self,
        which_nonzero: list[tuple[int, int]] | None = None,
        **kwargs: str | int | float | bool,
    ) -> None:
        """Compute the matrix M in VQITE in parallel using MPI.

        The computation is distributed across MPI processes, with each process
        calculating a subset of the matrix elements. The results are then gathered and
        combined into the full matrix.

        Parameters
        ----------
        which_nonzero : list[tuple[int, int]] | None, optional
            List of index tuples specifying which M matrix elements to compute.
            If None, computes all elements. Default is None.
        **kwargs : dict
            Keyword arguments passed to Quimb tensor contraction methods:
            - optimize : str
                Optimization strategy for finding contraction paths
            - simplify_sequence : str
                Tensor network simplifications to apply
            - backend : str
                Backend for performing contractions (e.g. 'numpy', 'cupy' for GPU)
            - memory_limit : int
                Maximum memory allowed for contractions
            - progbar : bool
                Whether to show a progress bar

        Notes
        -----
        - The M matrix is symmetric, so only upper triangular elements are computed
        - Results are stored in self._m, self._m_width, and self._m_cost
        - Uses MPI parallelization with processes divided evenly across matrix elements
        - Each process computes tensor contractions for its assigned elements

        """
        if which_nonzero is None:
            ind_list = [
                (mu, nu) for nu in range(len(self._ansatz)) for mu in range(nu + 1)
            ]
        else:
            ind_list = which_nonzero

        bins_sizes = [int(len(ind_list) / self._size) for _ in range(self._size)]
        for i in range(len(ind_list) - int(len(ind_list) / self._size) * self._size):
            bins_sizes[i] = bins_sizes[i] + 1
        start = sum(bins_sizes[: self._rank])
        end = start + bins_sizes[self._rank]

        m_interm = np.zeros(end - start)
        m_interm_cost = np.zeros(end - start)
        m_interm_width = np.zeros(end - start)

        m_nonzero = np.zeros(len(ind_list))
        m_nonzero_cost = np.zeros(len(ind_list))
        m_nonzero_width = np.zeros(len(ind_list))

        for i, (mu, nu) in enumerate(ind_list[start:end]):
            contr_mu_nu = self.contr1_est(mu=mu, nu=nu, **kwargs)
            m_interm[i] = (
                contr_mu_nu[-1]
                + self.contr2_est(mu=mu, **kwargs)[-1]
                * self.contr2_est(mu=nu, **kwargs)[-1]
            )
            (m_interm_width[i], m_interm_cost[i]) = (contr_mu_nu[0], contr_mu_nu[1])

        sendcountes = tuple(bins_sizes)
        displacements = tuple([sum(bins_sizes[:i]) for i in range(self._size)])
        if mpi_available:
            self._comm.Allgatherv(
                [m_interm, MPI.DOUBLE],
                [m_nonzero, sendcountes, displacements, MPI.DOUBLE],
            )
            self._comm.Allgatherv(
                [m_interm_cost, MPI.DOUBLE],
                [m_nonzero_cost, sendcountes, displacements, MPI.DOUBLE],
            )
            self._comm.Allgatherv(
                [m_interm_width, MPI.DOUBLE],
                [m_nonzero_width, sendcountes, displacements, MPI.DOUBLE],
            )
        else:
            m_nonzero = m_interm
            m_nonzero_cost = m_interm_cost
            m_nonzero_width = m_interm_width
        self._m = np.zeros((len(self._ansatz), len(self._ansatz)))
        for i in range(len(ind_list)):
            self._m[ind_list[i]] = m_nonzero[i]
            self._m[ind_list[i][::-1]] = m_nonzero[i]
        self._m_width = np.zeros((len(self._ansatz), len(self._ansatz)))
        for i in range(len(ind_list)):
            self._m_width[ind_list[i]] = m_nonzero_width[i]
            self._m_width[ind_list[i][::-1]] = m_nonzero_width[i]
        self._m_cost = np.zeros((len(self._ansatz), len(self._ansatz)))
        for i in range(len(ind_list)):
            self._m_cost[ind_list[i]] = m_nonzero_cost[i]
            self._m_cost[ind_list[i][::-1]] = m_nonzero_cost[i]

    def compute_v(
        self, optimize: str | dict = "greedy", **kwargs: str | int | float | bool
    ) -> None:
        """Compute vector V in VQITE in parallel using parameter shift rule.

        Each parallel process calculates the expectation value of a particular
        Pauli string in the Hamiltonian.

        Parameters
        ----------
        optimize : str or dict
            Specifies the optimization strategy for tensor network contractions:
            - If str: Uses Quimb's built-in optimization method (e.g. "greedy")
            - If dict: Uses pre-computed contraction paths for each Pauli string
        **kwargs : dict
            Additional arguments for Quimb's tensor network operations:
            - simplify_sequence: str
                Sequence of tensor network simplifications to apply
            - backend: str
                Computation backend
            - memory_limit: int
                Maximum memory allowed for contractions
            - cutoff: float
                SVD truncation threshold for tensor simplification

        Notes
        -----
        The computation is distributed such that each MPI process handles a subset of
        the required expectation value calculations. Results are then gathered and
        combined to form the complete V vector.

        """
        n_of_exp_vals = len(self.params) * 2 * len(self._H.paulis)

        self._exp_vals = np.zeros(n_of_exp_vals)

        bins_sizes = [int(n_of_exp_vals / self._size) for _ in range(self._size)]
        for i in range(n_of_exp_vals - int(n_of_exp_vals / self._size) * self._size):
            bins_sizes[i] = bins_sizes[i] + 1
        start = sum(bins_sizes[: self._rank])
        end = start + bins_sizes[self._rank]

        exp_vals_iterm = np.zeros(end - start)

        for i, ind in enumerate(range(start, end)):
            # parameter index for this process
            mu = int(int(ind / len(self._H.paulis)) / 2)

            params = self.params.copy()
            # parameter shift rule
            if int(ind / len(self._H.paulis)) % 2 == 0:
                params[mu] = params[mu] + np.pi / 2
            else:
                params[mu] = params[mu] - np.pi / 2

            qc = self._base_circuits[-1].copy()
            # update parameters
            old_params_dict = qc.get_params()
            new_params_dict = {
                key: np.array([params[j]])
                for j, key in enumerate(old_params_dict.keys())
            }
            qc.set_params(new_params_dict)

            pauli_str_ind = ind % len(self._H.paulis)
            pauli_str = self._H.paulis[pauli_str_ind]

            if isinstance(optimize, dict):
                exp_vals_iterm[i] = np.real(
                    p_str_exp_eval(
                        qc=qc,
                        pauli_str=pauli_str,
                        optimize=optimize[pauli_str],
                        **kwargs,
                    )
                )
            else:
                exp_vals_iterm[i] = np.real(
                    p_str_exp_eval(
                        qc=qc,
                        pauli_str=pauli_str,
                        optimize=optimize,
                        **kwargs,
                    )
                )

        sendcountes = tuple(bins_sizes)
        displacements = tuple([sum(bins_sizes[:i]) for i in range(self._size)])
        # collecting an array of the expectation values for all Pauli strings
        if mpi_available:
            self._comm.Allgatherv(
                [exp_vals_iterm, MPI.DOUBLE],
                [self._exp_vals, sendcountes, displacements, MPI.DOUBLE],
            )
        else:
            self._exp_vals = exp_vals_iterm
        # computing Hamiltonian expectation values for different parameters
        h_exp_vals = [
            sum(
                [
                    self._exp_vals[param_ind * len(self._H.coefs) + i]
                    * self._H.coefs[i]
                    for i in range(len(self._H.coefs))
                ]
            )
            for param_ind in range(len(self.params) * 2)
        ]
        self._v = np.array(
            [
                np.real(
                    -1
                    / 2
                    * (h_exp_vals[param_ind * 2] - h_exp_vals[param_ind * 2 + 1])
                    / 2
                )
                for param_ind in range(len(self.params))
            ]
        )

    def get_dthdt(self, delta: float, m: np.ndarray, v: np.ndarray) -> np.ndarray:
        """Compute parameter vector gradient.

        Parameters
        ----------
        delta : float
            Tikhonov regularization parameter for computing inverse of a matrix.
        m : numpy.ndarray
            Matrix M.
        v : numpy.ndarray
            Vector V.

        Returns
        -------
        numpy.ndarray
            Parameter gradient vector dθ/dt of shape (n,) used to update parameters
            in imaginary time evolution step

        """
        a = m + delta * np.eye(m.shape[0])
        ainv = np.linalg.inv(a)
        dthdt: np.ndarray = ainv.dot(v)
        return dthdt

    def vqite(
        self,
        delta: float = 1e-4,
        dt: float = 0.02,
        optimize_m: str = "greedy",
        optimize_v: str = "greedy",
        **kwargs: str | int | float | bool,
    ) -> None:
        """Perform VQITE routine.

        Parameters
        ----------
        delta : float
            Tikhonov regularization parameter for computing inverse of a matrix.
        dt : float
            Imaginary time step.
        optimize_m : string
            Optimizer to use when looking for contraction paths for M matrix.
        optimize_v : string or dict[cotengra.core.ContractionTree]
            Optimizer to use when looking for contraction paths for V vector.
            If dict, then entries should correspond to a contraction tree for
            each Pauli in the Hamiltonian (this is to reuse contraction paths).
        **kwargs
            Arguments used in Quimb methods for tensor contraction
            evaluations, such as (note that optimize parameter is specified
            separately):
                simplify_sequence : str
                    TN simplifications to use when looking for contraction paths.
                backend : str
                    Backend to use when performing the contractions.
                    Usually specified if GPU acceleration is needed.
                ...

        """
        _iter: int = 0
        if self._rank == 0:
            self.log("Starting VQITE calculation...")
        while True:
            if mpi_available:
                t1: float = MPI.Wtime()
            else:
                t1: float = time.time()
            if _iter == 0:
                # For the first iteration, need to compute the entire matrix
                # since it is not known a priori which elements are zero.
                self.compute_m(optimize=optimize_m, which_nonzero=None, **kwargs)
                # Save locations of nonzero elements.
                non_zero_els = np.where(np.abs(self._m) > 1e-14)
                self.which_nonzero = [
                    (non_zero_els[0][i], non_zero_els[1][i])
                    for i in range(len(non_zero_els[0]))
                    if non_zero_els[0][i] <= non_zero_els[1][i]
                ]
                if self._rank == 0:
                    self.log(f"# of nonzero elements of M: {len(self.which_nonzero)}")
            else:
                # For iterations after the first one, need to compute only
                # nonzero elements
                self.compute_m(
                    optimize=optimize_m, which_nonzero=self.which_nonzero, **kwargs
                )
            if mpi_available:
                t2: float = MPI.Wtime()
            else:
                t2: float = time.time()
            self.compute_v(optimize=optimize_v, **kwargs)
            if mpi_available:
                t3: float = MPI.Wtime()
            else:
                t3: float = time.time()
            dthdt: np.ndarray = self.get_dthdt(delta=delta, m=self._m, v=self._v)
            params_new = [
                p + pp * dt for p, pp in zip(self.params, dthdt, strict=False)
            ]
            self.params = params_new
            self.update_params()
            self._e: complex = self.h_exp_val(
                params=self.params, optimize=optimize_v, **kwargs
            )
            if self._rank == 0:
                self.log(
                    f"iter: "
                    f"{_iter}"
                    f", M matrix time: "
                    f"{t2 - t1}"
                    f", V vector time: "
                    f"{t3 - t2}"
                    f", Energy: "
                    f"{self._e}"
                )
            self._vmax: float = np.max(np.abs(self._v))
            # Convergence condition.
            if self._vmax < 1e-4:
                break
            _iter += 1

    def h_terms_find_contractions(self, **kwargs: str | int | float | bool) -> None:
        """Find tensor network contractions for Hamiltonian term expectation values.

        This method precomputes and stores the tensor network contractions needed to
        evaluate expectation values of each Pauli string term in the Hamiltonian.

        The contractions are stored in two dictionaries:
            self.h_terms_reh_dict : dict
                Maps each Pauli string to its rehearsal contraction data
            self.optimize_dict : dict
                Maps each Pauli string to its optimized contraction tree

        The precomputed contractions can be reused across iterations to avoid
        redundant computation of contraction paths.

        """
        self.h_terms_reh_dict: dict = {}
        self.optimize_dict: dict = {}
        qc = self._base_circuits[-1].copy()
        for pauli_str in self._H.paulis:
            self.h_terms_reh_dict[pauli_str] = p_str_exp_contr_path(
                qc=qc, pauli_str=pauli_str, **kwargs
            )
            self.optimize_dict[pauli_str] = self.h_terms_reh_dict[pauli_str]["tree"]

    def h_exp_val(
        self,
        params: list[float] | None = None,
        optimize: str | dict = "greedy",
        **kwargs: str | int | float | bool,
    ) -> complex:
        """Compute the expectation value of the Hamiltonian using Quimb.

        The expectation value is calculated by evaluating each Pauli string term in
        the Hamiltonian using tensor network contractions via Quimb.
        The results are weighted by the coefficients and summed to get the total energy
        expectation value.

        Parameters
        ----------
        params : List[float] or None
            Parameters for the variational quantum circuit that defines the state.
            If None, uses the current parameters stored in the object.
        optimize : str or dict
            Specifies how to optimize the tensor network contractions:
            - If str: Uses Quimb's built-in optimizer (e.g. "greedy", "dynamic", etc.)
            - If dict: Maps each Pauli string to a pre-computed optimal contraction tree
        **kwargs : dict
            Additional arguments passed to Quimb's contraction methods, including:
            simplify_sequence : str
                Sequence of tensor network simplifications to apply (e.g. "ADCRS")
            backend : str
                Hardware backend for computations ("numpy", "cupy" for GPU, etc.)

        Returns
        -------
        complex
            The expectation value

        Notes
        -----
        For large systems, using pre-computed contraction trees via the optimize dict
        can significantly improve performance by avoiding redundant path optimizations.

        """
        qc = self._base_circuits[-1].copy()

        if params is not None:
            old_params_dict = qc.get_params()
            new_params_dict = {
                key: np.array([params[i]])
                for i, key in enumerate(old_params_dict.keys())
            }
            qc.set_params(new_params_dict)

        h_exp_vals = []
        for pauli_str in self._H.paulis:
            if isinstance(optimize, dict):
                exp_val = p_str_exp_eval(
                    qc=qc, pauli_str=pauli_str, optimize=optimize[pauli_str], **kwargs
                )
                h_exp_vals.append(exp_val)
            else:
                h_exp_vals.append(
                    p_str_exp_eval(
                        qc=qc, pauli_str=pauli_str, optimize=optimize, **kwargs
                    )
                )
        exp_value: complex = sum(
            [h_exp_vals[i] * self._H.coefs[i] for i in range(len(self._H.coefs))]
        )
        return exp_value

    def circuit_1(self, mu: int, nu: int, a_mu: str, a_nu: str) -> qtn.Circuit:
        r"""Construct a quantum circuit.

        This method creates a circuit of the form:
        U^{\dag}_{0,\nu-1} A_{\nu} U_{\mu,\nu-1} A_{\mu} U_{0,\mu-1}|ref>
        where:
        - |ref> is the reference state

        Parameters
        ----------
        mu : int
            Index for placement of the first Pauli operator A_{\mu}.
        nu : int
            Index for placement of the second Pauli operator A_{\nu}.
        a_mu : str
            Pauli string operator A_{\mu} to insert at index mu.
        a_nu : str
            Pauli string operator A_{\nu} to insert at index nu.

        Returns
        -------
        qtn.Circuit
            Quimb circuit object implementing the required unitary transformation.

        Raises
        ------
        ValueError
            If mu >= nu or if either index exceeds the ansatz length.

        """
        if mu >= nu:
            raise ValueError("Here mu<nu is required.")
        if mu > len(self._ansatz) or nu > len(self._ansatz):
            raise ValueError(
                "mu, nu has to be smaller than the number of operators in the ansatz"
            )
        qc = self._base_circuits[mu].copy()
        qc.apply_gates(pauli_string_to_quimb_gates(pauli_string=a_mu), contract=False)
        for i in range(mu, nu):
            qc.apply_gates(self._pauli_rot_gates_list[i], contract=False)
        qc.apply_gates(pauli_string_to_quimb_gates(pauli_string=a_nu), contract=False)
        for i in reversed(range(nu)):
            qc.apply_gates(self._pauli_rot_dag_gates_list[i], contract=False)

        [
            self._init_qc.apply_gate("X", i)
            for i, el in enumerate(self._ref_state)
            if el == "1"
        ]

        return qc

    def circuit_2(self, mu: int) -> qtn.Circuit:
        r"""Construct a quantum circuit.

        This method creates a circuit of the form:
        U_{0,\mu-1}|ref>
        where:
        - |ref> is the reference state

        Parameters
        ----------
        mu : int
            Index up to which Pauli rotations from the ansatz are applied.
            The circuit will include rotations from indices 0 to mu-1.

        Returns
        -------
        qtn.Circuit
            Quimb circuit object implementing the required unitary transformation.

        Notes
        -----
        This circuit is used as a building block for constructing more complex circuits
        in the VQITE algorithm. It represents the initial portion of the full ansatz
        up to rotation index mu.

        """
        qc = self._init_qc.copy()
        for i in range(mu):
            qc.apply_gates(self._pauli_rot_gates_list[i], contract=False)
        return qc

    def contr1_est(
        self,
        mu: int,
        nu: int,
        backend: str | None = None,
        **kwargs: str | int | float | bool,
    ) -> tuple[float, float, complex]:
        r"""Calculate tensor network contraction metrics for a specific overlap term.

        This method computes the contraction width, cost and value for the overlap:
        <ref|U^{\dag}_{0,\nu-1} A_{\nu} U_{\mu,\nu-1} A_{\mu} U_{0,\mu-1}|ref>

        This overlap term appears in the calculation of matrix elements for the VQITE
        algorithm. The calculation involves constructing a tensor network representing
        the circuit and finding an optimal contraction sequence.

        Parameters
        ----------
        mu : int
            Index \mu specifying the position of the first Pauli operator A_{\mu}.
            Must satisfy 0 ≤ \mu < len(ansatz).
        nu : int
            Index \nu specifying the position of the second Pauli operator A_{\nu}.
            Must satisfy \mu ≤ \nu < len(ansatz).
        **kwargs : dict
            Additional arguments for tensor network contraction, including:
            - optimize : str
                Contraction path optimizer (e.g. "greedy", "optimal")
            - simplify_sequence : str
                Sequence of tensor network simplifications
            - memory_limit : int
                Maximum intermediate tensor size in bytes
        backend : str, optional
            Hardware backend for tensor contractions. Options include:
            - "numpy" : CPU-based calculations (default)
            - "cupy" : GPU-accelerated calculations

        Returns
        -------
        width : float
            Contraction width - logarithm of maximum intermediate tensor size
        cost : float
            Contraction cost - logarithm of total number of operations
        contraction : complex
            Numerical value of the contracted tensor network

        Notes
        -----
        The contraction value is normalized by a factor of 1/4 to match the
        conventions used in the VQITE algorithm. For \mu = \nu, the overlap reduces
        to identity and returns (1, 0, 1).

        """
        if mu > len(self._ansatz) or nu > len(self._ansatz):
            raise ValueError(
                "mu, nu has to be smaller than the number of operators in the ansatz"
            )
        if mu > nu:
            raise ValueError("it is assumed here that mu<=nu")
        if mu < nu:
            qc = self.circuit_1(mu, nu, a_mu=self._ansatz[mu], a_nu=self._ansatz[nu])
            reh = qc.amplitude_rehearse("0" * self._num_qubits, **kwargs)
            width, cost = reh["W"], reh["C"]
            contraction = reh["tn"].contract(
                all, optimize=reh["tree"], output_inds=(), backend=backend
            )
        if mu == nu:
            width, cost, contraction = (1, 0, 1)
        contraction = np.real(contraction) / 4
        return width, cost, contraction

    def contr2_est(
        self, mu: int, backend: str | None = None, **kwargs: str | int | float | bool
    ) -> tuple[float, float, complex]:
        r"""Calculate tensor network contraction metrics for a specific VQITE term.

        This method evaluates the tensor network corresponding to the expectation value:
        <ref|U^{\dag}_{0,\mu-1} A_{\mu} U_{0,\mu-1}|ref>
        where:
        - |ref> is the reference state

        This term appears in the VQITE algorithm when computing elements of the
        M matrix and V vector used to update the variational parameters.

        Parameters
        ----------
        mu : int
            Index of the Pauli operator A_{\mu} from the ansatz to evaluate
        **kwargs : dict
            Additional arguments for tensor network contraction:
            optimize : str
                Contraction path optimizer (e.g. "greedy", "optimal")
            simplify_sequence : str
                Sequence of tensor network simplifications (e.g. "ADCRS")
            memory_limit : int
                Maximum intermediate tensor size in bytes
            backend : str, optional
                Hardware backend for tensor contractions:
                - "numpy" : CPU-based calculations (default)
                - "cupy" : GPU-accelerated calculations

        Returns
        -------
        width : float
            Logarithm of maximum intermediate tensor size during contraction
        cost : float
            Logarithm of total number of contraction operations
        contraction : complex
            Numerical value of the contracted tensor network, normalized by i/2
            to match VQITE conventions

        Notes
        -----
        The contraction value represents a term in the gradient used to update
        the variational parameters in the VQITE algorithm. The i/2 normalization
        factor ensures consistency with the theoretical derivation.

        """
        if mu > len(self._ansatz):
            raise ValueError(
                "mu has to be smaller than the number of operators in the ansatz"
            )
        qc = self._base_circuits[mu]
        reh = p_str_exp_contr_path(qc=qc, pauli_str=self._ansatz[mu], **kwargs)
        contraction = reh["tn"].contract(
            all, optimize=reh["tree"], output_inds=(), backend=backend
        )
        contraction = np.real(1j * contraction / 2)
        return reh["W"], reh["C"], contraction


def add_pauli_rotation_gate(
    qc: qtn.Circuit,
    pauli_string: str,
    theta: float,
    decompose_rzz: bool = True,
) -> qtn.Circuit:
    r"""Append a Pauli rotation gate to a Quimb Circuit.

    The Pauli string ordering follows the opposite convention from Qiskit - in a string
    like "XYZ", X acts on qubit 0, Y on qubit 1, and Z on qubit 2.

    Parameters
    ----------
    qc : quimb.tensor.circuit.Circuit
        The quantum circuit to append the Pauli rotation gate to.
    pauli_string : str
        String of Pauli operators ('I', 'X', 'Y', 'Z') defining the rotation axis.
        Must have same length as number of qubits in circuit.
    theta : float
        Rotation angle in radians.
    decompose_rzz : bool, default=True
        If True, decomposes RZZ gates into a sequence of CNOT and RZ gates.
        If False, keeps RZZ gates in the circuit.

    Returns
    -------
    quimb.tensor.circuit.Circuit
        The input circuit with the Pauli rotation gate appended. The gate is
        parameterized to allow for parameter updates.

    Notes
    -----
    The rotation implements the unitary U = exp(-i θ P/2) where P is the tensor
    product of Pauli operators specified by pauli_string. Single-qubit rotations
    use native RX/RY/RZ gates, while multi-qubit rotations are decomposed into
    a sequence of CNOT gates and single-qubit rotations.

    """
    if qc.N != len(pauli_string):
        raise ValueError("Circuit and Pauli string are of different size")
    if not all(pauli in "IXYZ" for pauli in pauli_string):
        raise ValueError("Pauli string does not have a correct format")

    nontriv_pauli_list = [
        (i, pauli) for i, pauli in enumerate(pauli_string) if pauli != "I"
    ]
    if len(nontriv_pauli_list) == 1 and nontriv_pauli_list[0][1] in "XYZ":
        qc.apply_gate(
            f"R{nontriv_pauli_list[0][1]}",
            theta,
            nontriv_pauli_list[0][0],
            parametrize=True,
            gate_opts={"contract": False},
        )
    elif len(nontriv_pauli_list) == 2 and nontriv_pauli_list[0][1] + nontriv_pauli_list[
        1
    ][1] in ["XX", "YY"]:
        qc.apply_gate(
            f"R{nontriv_pauli_list[0][1] + nontriv_pauli_list[1][1]}",
            theta,
            nontriv_pauli_list[0][0],
            nontriv_pauli_list[1][0],
            parametrize=True,
            gate_opts={"contract": False},
        )
    else:
        for i, pauli in nontriv_pauli_list:
            if pauli == "X":
                qc.apply_gate("H", i)
            if pauli == "Y":
                qc.apply_gate("SDG", i)
                qc.apply_gate("H", i)
        for list_ind in range(len(nontriv_pauli_list) - 2):
            qc.apply_gate(
                "CX",
                nontriv_pauli_list[list_ind][0],
                nontriv_pauli_list[list_ind + 1][0],
            )
        if decompose_rzz is True:
            qc.apply_gate(
                "CX",
                nontriv_pauli_list[len(nontriv_pauli_list) - 2][0],
                nontriv_pauli_list[len(nontriv_pauli_list) - 1][0],
            )
            qc.apply_gate(
                "RZ",
                theta,
                nontriv_pauli_list[len(nontriv_pauli_list) - 1][0],
                parametrize=True,
                gate_opts={"contract": False},
            )
            qc.apply_gate(
                "CX",
                nontriv_pauli_list[len(nontriv_pauli_list) - 2][0],
                nontriv_pauli_list[len(nontriv_pauli_list) - 1][0],
            )
        if decompose_rzz is False:
            qc.apply_gate(
                "RZZ",
                theta,
                nontriv_pauli_list[len(nontriv_pauli_list) - 2][0],
                nontriv_pauli_list[len(nontriv_pauli_list) - 1][0],
                parametrize=True,
                gate_opts={"contract": False},
            )
        for list_ind in reversed(range(len(nontriv_pauli_list) - 2)):
            qc.apply_gate(
                "CX",
                nontriv_pauli_list[list_ind][0],
                nontriv_pauli_list[list_ind + 1][0],
            )
        for i, pauli in nontriv_pauli_list:
            if pauli == "X":
                qc.apply_gate("H", i)
            if pauli == "Y":
                qc.apply_gate("H", i)
                qc.apply_gate("S", i)
    return qc


def read_adaptvqite_ansatz(filename: str) -> tuple[list[str], list[float]]:
    """Read ansatz from an adaptive calculation.

    Loads the variational ansatz (sequence of Pauli strings) and corresponding
    parameters (rotation angles) from a pickle file containing results from a
    previous adaptive VQITE calculation.

    Parameters
    ----------
    filename : str
        Path to the pickle file (.pkle) containing the adaptive VQITE results.
        The file must contain a tuple of (ansatz, parameters) saved using pickle.

    Returns
    -------
    ansatz_adaptvqite : list[str]
        List of Pauli strings defining the variational ansatz. Each string
        represents a tensor product of Pauli operators (e.g. "IXYZ").
    params_adaptvqite : list[np.float64]
        List of variational parameters/angles corresponding to each Pauli
        string in the ansatz. These parameters define rotations in the
        quantum circuit.

    Raises
    ------
    ImportError
        If the provided filename does not have a .pkle extension.

    Notes
    -----
    The pickle file should contain exactly two elements:
    1. A list of Pauli strings representing the ansatz
    2. A list of floating point numbers for the parameters

    The ansatz and parameters can be used to reconstruct the optimized
    quantum circuit from the adaptive VQITE calculation.

    """
    if not filename.endswith(".pkle"):
        raise ImportError("Ansatz file should be given in .pkle format")

    with open(filename, "rb") as inp:
        data_inp = pickle.load(inp)  # consider safer formats, such as JSON.
        ansatz_adaptvqite = data_inp[0]
        params_adaptvqite = data_inp[1]

    return ansatz_adaptvqite, params_adaptvqite


def pauli_string_to_quimb_gates(pauli_string: str) -> tuple[qtn.circuit.Gate, ...]:
    """Convert a Pauli string into a sequence of Quimb gates.

    Takes a string of Pauli operators ('X', 'Y', 'Z') and converts it into
    a tuple of corresponding Quimb gate objects that can be applied to a circuit.

    Parameters
    ----------
    pauli_string : str
        String of Pauli operators ('X', 'Y', 'Z') defining the gates.

    Returns
    -------
    tuple[qtn.circuit.Gate, ...]
        Tuple of Quimb gate objects corresponding to the non-identity Pauli
        operators in the input string.

    Notes
    -----
    The Pauli string ordering follows the opposite convention from Qiskit - in a string
    like "XYZ", X acts on qubit 0, Y on qubit 1, and Z on qubit 2.

    """
    return tuple(
        qtn.circuit.Gate(label=el, params=[], qubits=(i,))
        for i, el in enumerate(pauli_string)
        if el in "XYZ"
    )


def p_str_exp_contr_path(
    qc: qtn.circuit.Circuit, pauli_str: str, **kwargs: str | int | float | bool
) -> dict[str, list | float]:
    """Constuct a contraction path for a TN evaluating the expectation value.

    This function takes a quantum circuit and a Pauli string operator, and returns the
    optimal contraction path and tensor network.

    Parameters
    ----------
    qc : quimb.tensor.circuit.Circuit
        Quantum circuit representing the state |ψ> for which to compute
        the Pauli string expectation value.
    pauli_str : str
        String of Pauli operators ('I', 'X', 'Y', 'Z') defining the observable P.
        Must have same length as number of qubits in circuit.
    **kwargs : dict
        Arguments for Quimb tensor network contraction:
        optimize : str
            Contraction path optimizer (e.g. "greedy", "optimal")
        simplify_sequence : str
            Sequence of tensor network simplifications (e.g. "ADCRS")
        memory_limit : int
            Maximum intermediate tensor size in bytes
        backend : str
            Hardware backend for contractions (e.g. "numpy", "cupy")

    Returns
    -------
    dict
        Dictionary containing:
        'tree' : list
            Optimal contraction path sequence
        'tn' : TensorNetwork
            Tensor network
        'W' : float
            Contraction width (log of largest intermediate)
        'C' : float
            Contraction cost (log of total operations)

    Notes
    -----
    The contraction path is optimized to minimize both the maximum intermediate tensor
    size (width) and total number of operations (cost). The returned tensor network
    can be contracted using the optimal path to obtain the expectation value.

    """
    where = [i for i, p in enumerate(pauli_str) if p != "I"]
    paulis = [p for p in pauli_str if p != "I"]
    operator = qu.pauli(paulis[0])
    for i in range(1, len(where)):
        operator = operator & qu.pauli(paulis[i])
    reh: dict[str, list | float] = qc.local_expectation_rehearse(
        operator, where, **kwargs
    )
    return reh


def p_str_exp_eval(
    qc: qtn.circuit.Circuit, pauli_str: str, **kwargs: str | int | float | bool
) -> complex:
    """Evaluate the expectation value of a Pauli string using TN contraction.

    Parameters
    ----------
    qc : quimb.tensor.circuit.Circuit
        Quantum circuit representing a state for which the expectation value
        is computed.
    pauli_str : str
        Pauli string representing an observable.
    **kwargs : dict
        Arguments for Quimb tensor network contraction:
        optimize : str
            Optimizer to use when looking for contraction paths.
        simplify_sequence : str
            TN simplifications to use when looking for contraction paths.
        backend : str
            Backend to use when performing the contractions.
            Usually specified if GPU acceleration is needed.
        ...

    Returns
    -------
    exp_val : complex
        Expectation value of the Pauli string.

    """
    where = [i for i, p in enumerate(pauli_str) if p != "I"]
    paulis = [p for p in pauli_str if p != "I"]
    operator = qu.pauli(paulis[0])
    for i in range(1, len(where)):
        operator = operator & qu.pauli(paulis[i])
    exp_val: complex = qc.local_expectation(operator, where, **kwargs)
    return exp_val
